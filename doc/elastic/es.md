## elasticsearch基本概念
> 学技术吗，总要搞清楚弄明白，这样出现问题才能不慌。
## 概念
* 通过学习以及个人理解整理
* elastic的基本信息应该都有所了解就不过多赘述，刚开始我也同样有很多问题需要弄清楚，不能只会用还要深入了解。
* 首先就要了解es的倒排索引
  1. 什么是倒排索引？es在插入数据的时候会维护一张倒排索引表，可以极大的提高检索效率。一般我们查询一个数据都是通过key找value，而倒排索引简单来说既是通过value找key。
     举个例子，比如有个表里面有id和detail两个数据detail放在文章信息，我们插入数据的时候es会对detail进行分词，比如我插入一条id为`1`，detail为`心情不好`，es
     会对这句话进行分词为`心情`、`不好`，表示这两个词都对应id为1的数据
     ```
     心情  [1]
     不好  [1]
     ```
     我们继续往里插入一条数据
     ```
     id: 2
     detail: 今天心情不好
     ```
     这时就变成
     ```
     心情  [1,2]
     不好  [1,2]
     今天  [2]
     ```
  2. 通过以上插入的数据，检索`心情`，就会命中两条数据[1,2]   
* 了解es的文档存储（7.10以后type默认是_doc，表示文档,官方推荐使用默认)
  1. es是面向文档型数据存储库，一条数据在这里就是一个文档，用json做序列化。用过mysql在使用es很容易就让我们产出对应的感觉
    ```
    关系数据库      => 数据库       => 表         => 行            => 列(Columns)

    Elasticsearch => 索引(Index)  => 类型(type) => 文档(Docments) => 字段(Fields)  
    ```
  2. 索引
  > 索引的不变性  
  由于倒排索引的结构特性，在索引建立完成后对其进行修改将会非常复杂。再加上几层索引嵌套，更让索引的更新变成了几乎不可能的动作。
  所以索性设计成不可改变的：倒排索引被写入磁盘后是不可改变的，它永远不会修改。

  > 不变性有重要的价值：  
  1.不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。  
  2.一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。  
  3.其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。  
  4.写入单个大的倒排索引允许数据压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。  
  
  3. 分片  
  > 什么是分片
  ```
  分片是 Elasticsearch 在集群中分发数据的关键。  
  把分片想象成数据的容器。文档存储在分片中，然后分片分配到集群中的节点上。当集群扩容或缩小，Elasticsearch 将会自动在节点间迁移分片，以使集群保持平衡。  
  一个分片(shard)是一个最小级别“工作单元(worker unit)”，它只是保存了索引中所有数据的一部分。  
  这类似于 MySql 的分库分表，只不过 Mysql 分库分表需要借助第三方组件而 ES 内部自身实现了此功能。  
  分片可以是主分片(primary shard)或者是复制分片(replica shard)。
  ```
  > a. 主分片  
  ```
  {
    "settings": {
        "number_of_shards": 3,
        "number_of_replicas": 1
    }
  }
  number_of_shards：表示主分片的数量  
  number_of_replicas：表示分片副本，既复制分片
  ```
  > 主分片一旦创建便不可修改，原因与多分片的索引写入数据有关  
  ```
  shard = hash(routing) % number_of_primary_shards  
  routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数 。这个在 0 到 number_of_primary_shards 之间的余数，就是所寻求的文档所在分片的位置。  
  这解释了为什么要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。
  ```
  4. 副本  
  >
  
* 集群
  > 节点角色  
  > 1. master节点：负责保存和更新集群的一些元数据信息，之后同步到所有节点，所以每个节点都需要保存全量的元数据信息：
  > ```
  > 1. 集群的配置信息  
  > 2. 集群的节点信息  
  > 3. 模板template设置  
  > 4. 索引以及对应的设置、mapping、分词器和别名  
  > 5. 索引关联到的分片以及分配到的节点  
  > ```
  > 2. data节点：负责数据存储和查询
  > 3. coordinator节点：
  > ```
  > 1. 路由索引请求
  > 2. 聚合搜索结果集
  > 3. 分发批量索引请求
  > ```
  > 4. 选举机制  
  > **master选举**    
  > a. 选举策略  
  > 如果集群中存在master，认可该master，加入集群
  > 如果集群中不存在master，从具有master资格的节点中选id最小的节点作为master  
  > b. 选举时机  
  > 集群启动：后台启动线程去ping集群中的节点，按照上述策略从具有master资格的节点中选举出master
  > 现有的master离开集群：后台一直有一个线程定时ping master节点，超过一定次数没有ping成功之后，重新进行master的选举  
  > c. 避免脑裂(不能百分百防止）  
  > 脑裂问题是采用master-slave模式的分布式集群普遍需要关注的问题，脑裂一旦出现，会导致集群的状态出现不一致，导致数据错误甚至丢失。
  > ES避免脑裂的策略：过半原则，可以在ES的集群配置中添加一下配置，避免脑裂的发生 (节点数/2 + 1)
## 索引重建
> ES在创建好索引后，mapping的properties属性类型是不能更改的，只能添加。如果说需要修改字段就需要重新建立索引然后把旧数据导到新索引。
  
* 场景
  > ```
  > a. 索引的mapping发生变更：字段类型属性变更，分词器或者词典需要变更
  > b. 索引的settings发生变更：主分片数发生变更
  > c. 数据迁移
  > ```
* 方式
  > [reindex数据迁移](/doc/elastic/es-reindex.md)
  
## 索引变更字段
    

## 文章参考引用
* [理解ElasticSearch原理](https://www.jianshu.com/p/52b92f1a9c47)
* [elasticsearch脑裂解释](https://segmentfault.com/a/1190000004504225)
* [elasticsearch之reindex数据迁移](https://rstyro.github.io/blog/2020/10/23/Elasticsearch7%E4%B9%8BReindex%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E8%AF%A6%E8%A7%A3/)
* [分片的概念](https://www.jianshu.com/p/cc06f9adbe82)    